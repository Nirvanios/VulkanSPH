#version 450

#extension GL_EXT_debug_printf : enable

#define gridSize simulationInfo.gridSizeXYZcountW.xyz
#define cellCount simulationInfo.gridSizeXYZcountW.w

#if !defined(BRUTE) && !defined(GRID)
#define GRID
#endif

float M_PI = 3.1415;

float defaultKernel(in vec4 position, in float positionNorm, in float supportRadius) {
  if (positionNorm >= 0.0f && positionNorm <= supportRadius)
    return (315 / (64 * M_PI * pow(supportRadius, 9)))
        * pow(pow(supportRadius, 2) - pow(positionNorm, 2), 3);
  else
    return 0.0f;
}
vec4 gradientKernel(in vec4 position, in float positionNorm, in float supportRadius) {
  return -945 / (32 * M_PI * pow(supportRadius, 9)) * position
      * pow(pow(supportRadius, 2) - pow(positionNorm, 2), 2);
}
float gradientKernelScalar(in vec4 position, in float positionNorm, in float supportRadius) {
  return -945 / (32 * M_PI * pow(supportRadius, 9))
      * pow(pow(supportRadius, 2) - pow(positionNorm, 2), 2);
}
float laplacianKernel(in vec4 position, in float positionNorm, in float supportRadius) {
  return -945 / (32 * M_PI * pow(supportRadius, 9)) * (pow(supportRadius, 2) - pow(positionNorm, 2))
      * (3 * pow(supportRadius, 2) - 7 * pow(positionNorm, 2));
}
vec4 spikyGradientKernel(in vec4 position, in float positionNorm, in float supportRadius) {
  return -45 / (M_PI * pow(supportRadius, 6)) * (position / positionNorm)
      * pow(supportRadius - positionNorm, 2);
}
float viscosityLaplacianKernel(in vec4 position, in float positionNorm, in float supportRadius) {
  return 45 / (M_PI * pow(supportRadius, 6)) * (supportRadius - positionNorm);
}
float linearTentKernel(float distanceSurfaceParticle, float sdfCountourValue) {
  return (1 / distanceSurfaceParticle) * (1 + (sdfCountourValue / distanceSurfaceParticle))
      * int(sdfCountourValue < 0);
}
float contourSDF(vec3 position, vec3 isoDensityDistributionCenter, float distanceSurfaceParticle) {
  return length(position - isoDensityDistributionCenter) - distanceSurfaceParticle;
}

layout(push_constant) uniform Info {
  ivec4 gridSizeXYZcountW;
  vec4 GridOrigin;
  vec4 gravityForce;
  float particleMass;
  float restDensity;
  float viscosityCoefficient;
  float gasStiffnessConstant;
  float heatConductivity;
  float heatCapacity;
  float timeStep;
  float supportRadius;
  float tensionThreshold;
  float tensionCoefficient;
  uint particleCount;
}
simulationInfo;

struct ParticleRecord {
  vec4 position;
  vec4 velocity;
  vec4 previousVelocity;
  vec4 massDensityCenter;
  float massDensity;
  float pressure;
  float temperature;
  int gridID;
  float pressureForceLength;
  float surfaceArea;
  float weightingKernelFraction;
};

#define WALL_DAMPING 0.3f

layout(std430, binding = 0) buffer positionBuffer { ParticleRecord particleRecords[]; };

struct KeyValue {
  int key;  //Particle ID
  int value;//Cell ID
};

layout(std430, binding = 1) buffer Grid { KeyValue grid[]; };
layout(std430, binding = 2) buffer Indexes { int indexes[]; };

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void main() {
  const uint myId = gl_GlobalInvocationID.x;
  if (myId < simulationInfo.particleCount) {
    int myGridID = particleRecords[myId].gridID;
    int myGridIDxy = myGridID - ((myGridID / (gridSize.x * gridSize.y)) * gridSize.x * gridSize.y);
    ivec3 myGridID3D = ivec3(myGridIDxy % gridSize.x, myGridIDxy / gridSize.x,
                             myGridID / (gridSize.x * gridSize.y));
    /**
        * INTERNAL FORCES
        */

    //Compute pressure, viscosity force
    const float particleRadius = simulationInfo.supportRadius * 0.5;

    vec4 pressureForce = vec4(0.0f);
    vec4 viscosityForce = vec4(0.0f);
    float colorField = 0.0f;
    vec4 inwardSurfaceNormal = vec4(0.0f);
    float temperature = 0.0f;
    float surfaceArea = 0.0;

#if defined(GRID)

    for (int z = -1; z < 2; ++z) {
      if (myGridID3D.z + z < 0 || myGridID3D.z + z > gridSize.z) { continue; }
      for (int y = -1; y < 2; ++y) {
        if (myGridID3D.y + y < 0 || myGridID3D.y + y > gridSize.y) { continue; }
        for (int x = -1; x < 2; ++x) {
          if (myGridID3D.x + x < 0 || myGridID3D.x + x > gridSize.x - 1) { continue; }
          int currentGridID = myGridID + x + gridSize.x * (y + gridSize.y * z);
          if (currentGridID < 0 || currentGridID > cellCount) { continue; }
          int sortedID = indexes[currentGridID];
          if (sortedID == -1) { continue; }

          while (grid[sortedID].value == currentGridID && sortedID < simulationInfo.particleCount) {

            const int neighbourID = grid[sortedID].key;
            if (myId != neighbourID) {
              vec4 positionDiff =
                  particleRecords[myId].position - particleRecords[neighbourID].position;

              if (neighbourID != myId && length(positionDiff) < simulationInfo.supportRadius) {
                pressureForce -= simulationInfo.particleMass
                    * (particleRecords[myId].pressure + particleRecords[neighbourID].pressure)
                    / (2.f * particleRecords[neighbourID].massDensity)
                    * spikyGradientKernel(positionDiff, length(positionDiff),
                                          simulationInfo.supportRadius);
                viscosityForce +=
                    (particleRecords[neighbourID].velocity - particleRecords[myId].velocity)
                    * (simulationInfo.particleMass / particleRecords[neighbourID].massDensity)
                    * viscosityLaplacianKernel(positionDiff, length(positionDiff),
                                               simulationInfo.supportRadius);
                colorField +=
                    (simulationInfo.particleMass / particleRecords[neighbourID].massDensity)
                    * laplacianKernel(positionDiff, length(positionDiff),
                                      simulationInfo.supportRadius);
                inwardSurfaceNormal +=
                    (simulationInfo.particleMass / particleRecords[neighbourID].massDensity)
                    * gradientKernel(positionDiff, length(positionDiff),
                                     simulationInfo.supportRadius);

                temperature += ((4 * simulationInfo.particleMass)
                                / (particleRecords[neighbourID].massDensity
                                   * particleRecords[myId].massDensity))
                    * ((simulationInfo.heatConductivity * simulationInfo.heatConductivity)
                       / (simulationInfo.heatConductivity + simulationInfo.heatConductivity))
                    * (particleRecords[myId].temperature - particleRecords[neighbourID].temperature)
                    * gradientKernelScalar(positionDiff, length(positionDiff),
                                           simulationInfo.supportRadius);
                //TODO particle radius
                surfaceArea +=
                    linearTentKernel(particleRadius,
                                     contourSDF(particleRecords[neighbourID].position.xyz,
                                                particleRecords[neighbourID].massDensityCenter.xyz,
                                                particleRadius))
                    * (simulationInfo.particleMass / particleRecords[neighbourID].massDensity)
                    * (defaultKernel(positionDiff, length(positionDiff),
                                     simulationInfo.supportRadius)
                       / particleRecords[neighbourID].weightingKernelFraction);
              }
            }
            ++sortedID;
          }
        }
      }
    }

#elif defined(BRUTE)
    for (int i = 0; i < simulationInfo.particleCount; ++i) {
      vec4 positionDiff = particleRecords[myId].position - particleRecords[i].position;
      if (i != myId && length(positionDiff) < simulationInfo.supportRadius) {
        pressureForce -= simulationInfo.particleMass
            * (particleRecords[myId].pressure + particleRecords[i].pressure)
            / (2.f * particleRecords[i].massDensity)
            * spikyGradientKernel(positionDiff, length(positionDiff), simulationInfo.supportRadius);
        viscosityForce += (particleRecords[i].velocity - particleRecords[myId].velocity)
            * (simulationInfo.particleMass / particleRecords[i].massDensity)
            * viscosityLaplacianKernel(positionDiff, length(positionDiff),
                                       simulationInfo.supportRadius);
        colorField += (simulationInfo.particleMass / particleRecords[i].massDensity)
            * laplacianKernel(positionDiff, length(positionDiff), simulationInfo.supportRadius);
        inwardSurfaceNormal += (simulationInfo.particleMass / particleRecords[i].massDensity)
            * gradientKernel(positionDiff, length(positionDiff), simulationInfo.supportRadius);
      }
    }
#endif

    viscosityForce *= simulationInfo.viscosityCoefficient;
    vec4 internalForces = pressureForce + viscosityForce;
    particleRecords[myId].pressureForceLength = length(pressureForce);
    particleRecords[myId].surfaceArea =
        (simulationInfo.particleMass / particleRecords[myId].massDensity) * surfaceArea;

    /**
        * EXTERNAL FORCES
        */
    vec4 surfaceForce = vec4(0.0f);
    if (length(inwardSurfaceNormal) > simulationInfo.tensionThreshold) {
      surfaceForce = -simulationInfo.tensionCoefficient * colorField
          * (inwardSurfaceNormal / length(inwardSurfaceNormal));
    }
    vec4 externalForces =
        simulationInfo.gravityForce * particleRecords[myId].massDensity + surfaceForce;

    /**
        * TIME INTEGRATION
        */
    vec4 force = internalForces + externalForces;

    vec4 acceleration = force / particleRecords[myId].massDensity;

    vec4 newVelocity =
        particleRecords[myId].previousVelocity + acceleration * simulationInfo.timeStep;

    vec4 newPosition = particleRecords[myId].position + newVelocity * simulationInfo.timeStep;
    newVelocity = (particleRecords[myId].velocity + newVelocity) / 2.0;

    vec3 minBorder = simulationInfo.GridOrigin.xyz + simulationInfo.supportRadius * 0.1;
    vec3 maxBorder =
        minBorder + gridSize * simulationInfo.supportRadius - simulationInfo.supportRadius * 0.1;

    if (newPosition.x < minBorder.x) {
      newPosition.x = minBorder.x;
      newVelocity.x *= -1 * WALL_DAMPING;
    }
    if (newPosition.x > maxBorder.x) {
      newPosition.x = maxBorder.x;
      newVelocity.x *= -1 * WALL_DAMPING;
    }
    if (newPosition.y < minBorder.y) {
      newPosition.y = minBorder.y;
      newVelocity.y *= -1 * WALL_DAMPING;
    }
    if (newPosition.y > maxBorder.y) {
      newPosition.y = maxBorder.y;
      newVelocity.y *= -1 * WALL_DAMPING;
    }
    if (newPosition.z < minBorder.z) {
      newPosition.z = minBorder.z;
      newVelocity.z *= -1 * WALL_DAMPING;
    }
    if (newPosition.z > maxBorder.z) {
      newPosition.z = maxBorder.z;
      newVelocity.z *= -1 * WALL_DAMPING;
    }

    particleRecords[myId].velocity = (newVelocity + particleRecords[myId].velocity) / 2;
    particleRecords[myId].previousVelocity = newVelocity;
    particleRecords[myId].position = newPosition;

    particleRecords[myId].temperature +=
        (temperature * simulationInfo.timeStep) / simulationInfo.heatCapacity;
  }
}
